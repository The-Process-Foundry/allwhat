//! Test the mutability implementation

mod common;

/*
#[test]
/// Basic test of mutability of a primitive.
fn test_i32() {
  use common::*;

  let mut action = i32TryMut::Op(Box::new(|item: &mut i32| {
    // Convert it regardless
    *item += 10;

    if *item % 2 == 0 {
      // Evens are Ok
      Ok(())
    } else {
      // Odds throw an error
      Err(anyhow!("Eew, an odd"))
    }
  }));

  for i in 0..10 {
    println!("Running i: {}", i);
    let mut j = i.clone();
    match j.try_mut(&mut action) {
      PoisonedErr::Ok => {
        assert_eq!(j, i + 10);
      }
      PoisonedErr::Err(err) => {
        assert_eq!(j, i);
        assert_eq!(format!("{}", err), "Eew, an odd");
      }
      PoisonedErr::Poisoned(_, _) => panic!("This should never be poisoned"),
    }
  }
}
*/

/*
#[test]
/// Try to insert a new value into a hashmap. If the key already exists, roll it back.
fn test_hashmap_duplicate_key() {
  use common::*;

  use std::collections::HashMap;

  //---   Should be generated by proc_macro

  /// These are the actions
  enum HashMapAction {
    Insert,
  }


  impl Invertable for HashMapAction {
    type Error = AnyhowError;

    fn apply(&self, hash_map = &mut)
  }

  // #[derive(TryMut)]
  pub struct Demo(HashMap<i32, i32>);

  impl Revertable for Demo {
    type Action = DemoAction;
    type Error = AnyhowError;

    fn revert(
      &mut self,
      action: Self::Action,
      patch: Patch<Self::Error, Self::Action>,
    ) -> Result<(), AnyhowError> {
      unimplemented!("'Demo::revert' still needs to be implemented")
    }
  }

  impl Demo {
    // The return values include everything needed to rollback the change.
    pub fn try_insert(&mut self, key: i32, value: i32) -> PatchResult<AnyhowError, DemoAction> {
      let mut patch = HashMap::new();
      patch.insert("Key".to_string(), key);
      match self.0.insert(key, value) {
        None => PatchResult::Ok(
          (),
          Patch {
            action: "Demo::insert".to_string(),
            values: patch,
            revert: Box::new(|item: Demo| {
              item.0.remove(&key);
              // TODO: Think if this needs a validation that the removed value matches
              Ok(())
            }),
          },
        ),
        Some(old) => {
          self.0.insert(key, old);
          TryMutResult::Err(anyhow!(
            "Duplicate Key '{}' - Tried to replace value '{}' with '{}'",
            key,
            old,
            value
          ))
        }
      }
    }
  }

  let map = Demo(HashMap::new());
  assert_eq!(map.0.len(), 0);

  // let action = |map: &mut Demo, patch: &mut TransactionPatch| {
  // } item:  i32, value: i32,
}
*/
